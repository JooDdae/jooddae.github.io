---
title:  "Longest Path to WF 팀연습-2"
date: 2021-09-25 01:00:00
categories: 
- PS
tags:
- 팀연습

---





Longest Path to WF 팀연습 기록





# 2021/09/24 NEERC 2010

![image](https://user-images.githubusercontent.com/51346964/134753258-4faecc90-2b28-4923-9a68-2fb02db1a7a7.png)

**I** : 시작하자마자 읽고 좀 고민하니 풀이가 나왔다. 코딩큐를 기다리며 구현 구체화를 했고 바로 AC. N에서 BFS를 돌려 1부터 시작했을 때 갈 수 있는 경로를 찾을 수 있고, 사전순으로 빠른 경로가 나오도록 갈 수 있는 경로중 가장 $c$가 작은 경로만을 선택하게 다시 1부터 시작하는 BFS를 돌리면 된다.

평소와는 다르게 문제를 읽는 담당이 되었었다. 나는 풀이가 잘 나오지 않았었고, 기하 문제 및 비교적 쉬운 문제들을 두분이서 모두 해결하셨다.

**J** : 정말 열심히 구현했다. 다행히(?) BC의 풀이가 금방 나오지 않아 코딩큐가 비어있어서 여유롭게 코딩했다. 체감상 2시간은 잡은거 같다.

### Upsolved

**A** : 열심히 구현하면 된다. 누적합을 이용한다면 더 쉽게 구현할 수 있다.





# 2021/09/24 NEERC 2009

![image](https://user-images.githubusercontent.com/51346964/134751396-c4b948f2-27b0-41c6-b78a-7fd6b1057794.png)



**D** : I를 열심히 고민하고 있었는데, 풀이가 잘 나오지 않아 솔브가 나온 문제를 잡게 되었다. 간단한 map 기본문제

**F** : edenooo님이 I 풀이가 나와서 또다시 솔브가 나온 문제를 잡게 되었다. 단어의 길이가 짧으면 짧을수록 좋으니깐 한글자 단어부터 우선순위 큐에 넣고 하나씩 빼는데, 만약 그 단어가 단어장에 없으면 정답에 추가하고 아니라면 스킵한 뒤에 그 단어의 뒤에 26가지의 알파벳을 더한 문자열을 다시 우선순위 큐에 넣는다. 정답의 개수가 $N$개 미만 일때까지 반복하기 때문에 우선순위 큐에서 뽑히게 되는 단어의 개수는 최대 $N+M$개이고, 이 개수에 $26$을 곱한 만큼 우선순위 큐에 다시 들어가므로 충분히 시간내에 돈다.

**G** : 또또 솔브가 그나마 나온 문제를 잡게 되었다. $(n-1)(m-1)$번의 이동을 시뮬레이션 하면 각 $i$가 어디로 이동하는지, 그리고 $i$가 더해지는 횟수를 구할 수 있다. 이를 모든 $i$에 대해 저장하고 스파스 테이블을 $10^{100}$이 돌어갈 만큼 전처리해 놓는다면 각 $i$마다 로그에 답을 찾을 수 있게 된다. 코포에서는 256MB로 $ 10^{100} < 2^{334}$인 점을 이용해 아슬아슬하게 메모리 제한을 통과할 수 있었지만, 백준은 128MB라서 $10^{100} < 4^{167}$으로 메모리를 절반으로 줄인채로 맞았다.

### Upsolved



# 2021/09/24 NAIPC 2019

![image](https://user-images.githubusercontent.com/51346964/134815266-0268f032-a5b3-48d2-8ce2-b810400edb6e.png)

**J** : NM DP 를 세운뒤 경우의 수를 잘 세워주면 된다. 풀이가 금방 나왔는데 머리가 꼬여서 한번 갈아엎었다.

**M** : 이것저것 왔다갔다 하다가 솔브수가 나와서 잡았다. 구간을 절반씩 나눠가면서 경우의 수를 잘 세주면 된다. 나눠지는 두 구간에 속한 원소가 완전히 다른지, 아니면 두 구간의 원소가 순서까지 정확히 같은지 판별해야 하는데 각각을 서로 다른 수열과 쿼리 2, 해싱을 이용해 풀어 뇌절했다. 그냥 머지소트를 하는대로 나이브하게 구현해도 상한이 $O(N \log N)$임이 보장되기 때문에 코드도 짧게 나온다. 하지만 다시 구현하는 건 귀찮으므로 패스.

저번과 마찬가지로 문제를 읽는 담당이 되었다. 어려운 문제를 Aeren님이 다 푸셔서 성적은 잘 나왔는데 나는 거의 한게 없었다.. E번 풀이를 도와준 정도?

### Upsolved

**E** : $2^M$의 모든 경우에 마지막 두개 $i,j$​를 선택했을 때 가능한 $k$를 찾으면 된다. $i,j,k$쌍을 비교하기 위해 전처리로 $O(N^2M)$, DP를 전이하는 데 $O(N^3)$​으로 총 시간복잡도 $O(2^M(N^3+N^2M))$으로 빡빡하게 돌아간다. 코드를 보면서 디버깅을 도왔기 때문에 거의 그대로 코딩했다.

