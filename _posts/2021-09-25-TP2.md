---
title:  "Longest Path to WF 팀연습-2"
date: 2021-09-25 01:00:00
categories: 
- PS
tags:
- 팀연습
---





Longest Path to WF 팀연습 기록





# 2021/09/24 NEERC 2010

![image](https://user-images.githubusercontent.com/51346964/134753258-4faecc90-2b28-4923-9a68-2fb02db1a7a7.png)

**I** : 시작하자마자 읽고 좀 고민하니 풀이가 나왔다. 코딩큐를 기다리며 구현 구체화를 했고 바로 AC. N에서 BFS를 돌려 1부터 시작했을 때 갈 수 있는 경로를 찾을 수 있고, 사전순으로 빠른 경로가 나오도록 갈 수 있는 경로중 가장 $c$가 작은 경로만을 선택하게 다시 1부터 시작하는 BFS를 돌리면 된다.

평소와는 다르게 문제를 읽는 담당이 되었었다. 나는 풀이가 잘 나오지 않았었고, 기하 문제 및 비교적 쉬운 문제들을 두분이서 모두 해결하셨다.

**J** : 정말 열심히 구현했다. 다행히(?) BC의 풀이가 금방 나오지 않아 코딩큐가 비어있어서 여유롭게 코딩했다. 체감상 2시간은 잡은거 같다.

### Upsolved

**A** : 열심히 구현하면 된다. 누적합을 이용한다면 더 쉽게 구현할 수 있다.





# 2021/09/24 NEERC 2009

![image](https://user-images.githubusercontent.com/51346964/134751396-c4b948f2-27b0-41c6-b78a-7fd6b1057794.png)



**D** : I를 열심히 고민하고 있었는데, 풀이가 잘 나오지 않아 솔브가 나온 문제를 잡게 되었다. 간단한 map 기본문제

**F** : edenooo님이 I 풀이가 나와서 또다시 솔브가 나온 문제를 잡게 되었다. 단어의 길이가 짧으면 짧을수록 좋으니깐 한글자 단어부터 우선순위 큐에 넣고 하나씩 빼는데, 만약 그 단어가 단어장에 없으면 정답에 추가하고 아니라면 스킵한 뒤에 그 단어의 뒤에 26가지의 알파벳을 더한 문자열을 다시 우선순위 큐에 넣는다. 정답의 개수가 $N$개 미만 일때까지 반복하기 때문에 우선순위 큐에서 뽑히게 되는 단어의 개수는 최대 $N+M$개이고, 우선순위 큐에 다시 들어가는 문자열의 개수는 최대 $26 \cdot (N+M)$개이므로 이는 충분히 제한시간내에 돌게 다.

**G** : 또또 솔브가 그나마 나온 문제를 잡게 되었다. $(n-1)(m-1)$번의 이동을 시뮬레이션 하면 각 $i$가 어디로 이동하는지, 그리고 $i$가 더해지는 횟수를 구할 수 있다. 이를 모든 $i$에 대해 저장하고 스파스 테이블을 $10^{100}$이 돌어갈 만큼 전처리해 놓는다면 각 $i$마다 로그에 답을 찾을 수 있게 된다. 코포에서는 256MB로 $ 10^{100} < 2^{334}$인 점을 이용해 아슬아슬하게 메모리 제한을 통과할 수 있었지만, 백준은 128MB라서 $10^{100} < 4^{167}$으로 메모리를 절반으로 줄인채로 맞았다.

### Upsolved











